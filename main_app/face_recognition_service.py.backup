"""
Face Recognition Service for AI Attendance System
Implements Step 4 (Training) and Step 5 (Recognition) of the functional requirements
"""
import os
import cv2
import numpy as np
import pickle
from django.conf import settings
from django.core.files.storage import default_storage
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
import logging
from typing import List, Tuple, Optional, Dict
import json
from datetime import datetime

# Try to import face_recognition, handle gracefully if not available
try:
    import face_recognition
    FACE_RECOGNITION_AVAILABLE = True
except ImportError:
    FACE_RECOGNITION_AVAILABLE = False
    print("Warning: face_recognition library not available. Face recognition features will be disabled.")

logger = logging.getLogger(__name__)

class FaceRecognitionService:
    """
    Advanced Face Recognition Service for real-time attendance
    Uses face_recognition library with KNN classifier for robust recognition
    """
    
    def __init__(self):
        self.model_path = os.path.join(settings.MEDIA_ROOT, 'face_models')
        self.encodings_file = os.path.join(self.model_path, 'face_encodings.pkl')
        self.classifier_file = os.path.join(self.model_path, 'face_classifier.pkl')
        self.students_file = os.path.join(self.model_path, 'students_mapping.json')
        
        # Recognition parameters
        self.confidence_threshold = 0.6  # 60% confidence minimum
        self.max_face_distance = 0.6    # Maximum distance for face matching
        self.n_neighbors = 5             # KNN parameter
        
        # Ensure model directory exists
        os.makedirs(self.model_path, exist_ok=True)
        
        # Load existing models if available
        self.face_encodings = []
        self.face_labels = []
        self.students_mapping = {}
        self.classifier = None
        
        # Check if face recognition is available
        if not FACE_RECOGNITION_AVAILABLE:
            logger.warning("Face recognition library not available. Recognition features disabled.")
            return
        
        self._load_models()
    
    def generate_face_encodings(self, student_id: str, force_regenerate: bool = False) -> int:
        """
        Generate face encodings for a specific student from their enrollment images
        
        Args:
            student_id: Student ID to generate encodings for
            force_regenerate: Whether to regenerate existing encodings
            
        Returns:
            Number of encodings generated
        """
        if not FACE_RECOGNITION_AVAILABLE:
            logger.error("Face recognition library not available")
            return 0
            
        try:
            from .models import Student, EnrollmentImage
            
            student = Student.objects.get(student_id=student_id)
            images = EnrollmentImage.objects.filter(student=student)
            
            if not images.exists():
                logger.warning(f"No enrollment images found for student {student_id}")
                return 0
            
            encodings = []
            processed_count = 0
            
            logger.info(f"Processing {images.count()} images for student {student_id}")
            
            for img_obj in images:
                try:
                    # Load image file
                    image_path = img_obj.image.path
                    if not os.path.exists(image_path):
                        logger.warning(f"Image file not found: {image_path}")
                        continue
                    
                    # Load and process image
                    image = cv2.imread(image_path)
                    if image is None:
                        logger.warning(f"Could not load image: {image_path}")
                        continue
                    
                    # Convert BGR to RGB (face_recognition expects RGB)
                    rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                    
                    # Generate face encodings
                    face_locations = face_recognition.face_locations(rgb_image, model="hog")
                    
                    if len(face_locations) == 1:
                        # Only process if exactly one face is found
                        face_encodings_list = face_recognition.face_encodings(rgb_image, face_locations)
                        if face_encodings_list:
                            encodings.append(face_encodings_list[0])
                            processed_count += 1
                    elif len(face_locations) > 1:
                        logger.warning(f"Multiple faces found in {image_path}, skipping")
                    else:
                        logger.warning(f"No face found in {image_path}")
                        
                except Exception as e:
                    logger.error(f"Error processing image {image_path}: {str(e)}")
                    continue
            
            if encodings:
                # Store encodings for this student
                student_key = f"{student_id}_{student.name}"
                self.face_encodings.extend(encodings)
                self.face_labels.extend([student_key] * len(encodings))
                self.students_mapping[student_key] = {
                    'student_id': student_id,
                    'name': student.name,
                    'encoding_count': len(encodings)
                }
                
                logger.info(f"Generated {len(encodings)} encodings for student {student_id}")
                return len(encodings)
            else:
                logger.warning(f"No valid encodings generated for student {student_id}")
                return 0
                
        except Exception as e:
            logger.error(f"Error generating encodings for student {student_id}: {str(e)}")
            return 0
    
    def train_recognition_model(self) -> bool:
        """
        Train the face recognition model using all enrolled students
        
        Returns:
            True if training successful, False otherwise
        """
        try:
            from .models import Student
            
            # Clear existing data
            self.face_encodings = []
            self.face_labels = []
            self.students_mapping = {}
            
            # Generate encodings for all students
            students = Student.objects.all()
            total_encodings = 0
            
            logger.info(f"Training model with {students.count()} students")
            
            for student in students:
                encoding_count = self.generate_face_encodings(student.student_id)
                total_encodings += encoding_count
            
            if total_encodings < 10:  # Minimum threshold for training
                logger.error(f"Insufficient training data: only {total_encodings} encodings generated")
                return False
            
            # Train KNN classifier
            if len(self.face_encodings) > 0:
                self.classifier = KNeighborsClassifier(
                    n_neighbors=min(self.n_neighbors, len(set(self.face_labels))),
                    weights='distance',
                    metric='euclidean'
                )
                
                self.classifier.fit(self.face_encodings, self.face_labels)
                
                # Save models
                self._save_models()
                
                logger.info(f"Model trained successfully with {total_encodings} encodings from {len(set(self.face_labels))} students")
                return True
            else:
                logger.error("No face encodings available for training")
                return False
                
        except Exception as e:
            logger.error(f"Error training recognition model: {str(e)}")
            return False
    
    def recognize_face(self, image_array: np.ndarray) -> Tuple[Optional[str], float, Optional[str]]:
        """
        Recognize a face in the given image
        
        Args:
            image_array: Input image as numpy array (BGR format from OpenCV)
            
        Returns:
            Tuple of (student_id, confidence, student_name) or (None, 0.0, None) if no match
        """
        if not FACE_RECOGNITION_AVAILABLE:
            logger.error("Face recognition library not available")
            return None, 0.0, None
            
        try:
            if self.classifier is None:
                logger.warning("Recognition model not loaded. Please train the model first.")
                return None, 0.0, None
            
            # Convert BGR to RGB
            rgb_image = cv2.cvtColor(image_array, cv2.COLOR_BGR2RGB)
            
            # Find face locations
            face_locations = face_recognition.face_locations(rgb_image, model="hog")
            
            if len(face_locations) != 1:
                # Return no match if 0 or multiple faces found
                return None, 0.0, None
            
            # Generate encoding for the detected face
            face_encodings_list = face_recognition.face_encodings(rgb_image, face_locations)
            
            if not face_encodings_list:
                return None, 0.0, None
            
            face_encoding = face_encodings_list[0]
            
            # Use KNN classifier for prediction
            distances, indices = self.classifier.kneighbors([face_encoding])
            
            # Get the closest match
            closest_distance = distances[0][0]
            closest_label = self.face_labels[indices[0][0]]
            
            # Calculate confidence (inverse of distance, normalized)
            confidence = max(0.0, 1.0 - (closest_distance / self.max_face_distance))
            
            if confidence >= self.confidence_threshold and closest_distance <= self.max_face_distance:
                # Get student information
                student_info = self.students_mapping.get(closest_label, {})
                student_id = student_info.get('student_id')
                student_name = student_info.get('name')
                
                logger.info(f"Face recognized: {student_name} (ID: {student_id}) with confidence {confidence:.2f}")
                return student_id, confidence, student_name
            else:
                logger.debug(f"Face not recognized: confidence {confidence:.2f} below threshold {self.confidence_threshold}")
                return None, confidence, None
                
        except Exception as e:
            logger.error(f"Error during face recognition: {str(e)}")
            return None, 0.0, None
    
    def _save_models(self):
        """Save trained models to disk"""
        try:
            # Save face encodings and labels
            with open(self.encodings_file, 'wb') as f:
                pickle.dump({
                    'encodings': self.face_encodings,
                    'labels': self.face_labels
                }, f)
            
            # Save classifier
            with open(self.classifier_file, 'wb') as f:
                pickle.dump(self.classifier, f)
            
            # Save students mapping
            with open(self.students_file, 'w') as f:
                json.dump(self.students_mapping, f, indent=2)
            
            logger.info("Face recognition models saved successfully")
            
        except Exception as e:
            logger.error(f"Error saving models: {str(e)}")
    
    def _load_models(self):
        """Load trained models from disk"""
        try:
            # Load face encodings and labels
            if os.path.exists(self.encodings_file):
                with open(self.encodings_file, 'rb') as f:
                    data = pickle.load(f)
                    self.face_encodings = data['encodings']
                    self.face_labels = data['labels']
            
            # Load classifier
            if os.path.exists(self.classifier_file):
                with open(self.classifier_file, 'rb') as f:
                    self.classifier = pickle.load(f)
            
            # Load students mapping
            if os.path.exists(self.students_file):
                with open(self.students_file, 'r') as f:
                    self.students_mapping = json.load(f)
            
            if self.classifier is not None:
                logger.info(f"Face recognition models loaded: {len(self.face_encodings)} encodings for {len(set(self.face_labels))} students")
            
        except Exception as e:
            logger.error(f"Error loading models: {str(e)}")
            # Reset to empty state if loading fails
            self.face_encodings = []
            self.face_labels = []
            self.students_mapping = {}
            self.classifier = None
    
    def get_model_statistics(self) -> Dict:
        """Get statistics about the current model"""
        return {
            'total_encodings': len(self.face_encodings),
            'total_students': len(set(self.face_labels)) if self.face_labels else 0,
            'students_mapping': self.students_mapping,
            'model_trained': self.classifier is not None,
            'last_updated': datetime.now().isoformat() if self.classifier else None
        }
    
    def retrain_for_student(self, student_id: str) -> bool:
        """
        Retrain the model to include a newly enrolled student
        
        Args:
            student_id: ID of the student to add to the model
            
        Returns:
            True if successful, False otherwise
        """
        try:
            encoding_count = self.generate_face_encodings(student_id)
            
            if encoding_count > 0:
                # Retrain the classifier with updated data
                if len(self.face_encodings) > 0:
                    self.classifier = KNeighborsClassifier(
                        n_neighbors=min(self.n_neighbors, len(set(self.face_labels))),
                        weights='distance',
                        metric='euclidean'
                    )
                    
                    self.classifier.fit(self.face_encodings, self.face_labels)
                    self._save_models()
                    
                    logger.info(f"Model retrained successfully with new student {student_id}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error retraining model for student {student_id}: {str(e)}")
            return False

# Global instance
face_recognition_service = FaceRecognitionService()
